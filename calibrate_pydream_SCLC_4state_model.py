'''
Generated by pydream_it
PyDREAM run script for SCLC_popD_model.py 
'''
from pydream.core import run_dream
from pysb.simulator import ScipyOdeSimulator
import numpy as np
from pydream.parameters import SampledParam
from pydream.convergence import Gelman_Rubin
from scipy.stats import norm,uniform
from four_state_sclc import model
import seaborn as sns
from matplotlib import pyplot as plt
import copy
from itertools import chain

# DREAM Settings
# Number of chains - at least 3.
nchains = 5
# Number of iterations
niterations = 10000

#Initialize PySB solver object for running simulations.  Simulation timespan should match experimental data.
tspan = np.linspace(0,100, 101)
solver = ScipyOdeSimulator(model)
param_values = np.array([p.value for p in model.parameters])
parameters_idxs = list(np.arange(1,len(param_values)))
rates_mask = np.concatenate((np.zeros(1,dtype=bool),np.ones(len(param_values[1:]),dtype=bool)))
starting_position = np.log10(param_values[rates_mask])
starts = [np.array(starting_position) for i in range(nchains)]

def normalize(trajectory, trajectories):
    """even though this is not really needed, if the data is already between 1 and 0!"""
    """Rescale a matrix of model trajectories to 0-1"""
    ymin = min([y for x in trajectories for y in x])
    ymax = max([y for x in trajectories for y in x])
    return (trajectory - ymin) / (ymax - ymin)

# USER must add commands to import/load any experimental data for use in the likelihood function!
pct_data = {
'NE_obs': 0.44622156256910767,
'NEv1_obs': 0.017615778739465095,
'NEv2_obs': 0.4483862369313809,
'NonNE_obs': 0.08777642176004649
}

like_pct_data = {}
#for obs in model.observables:
for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
    like_pct_data[obs] = norm(loc=pct_data[obs],scale=(pct_data[obs]/10))

# access with x[()]['NE_obs']

# USER must define a likelihood function!
def likelihood(position):
    Y=np.copy(position)
    param_values[rates_mask] = 10 ** Y
    sim = solver.run(param_values=param_values,tspan=tspan).all
    sim_data_norm = {}
    for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
        sim_data_norm[obs] = normalize(sim[obs], [list(sim[i]) for i in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']])
    # Make the percentage data
    cell_tot = 0
    for i in sim_data_norm:
        cell_tot += sim_data_norm[i][-1]
    sim_pct = {}
    for i in sim_data_norm:
        sim_pct[i] = sim_data_norm[i][-1]/cell_tot
    # Score the percentage data
    pct_costs = []
    for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
        pct_costs.append(np.sum(like_pct_data[obs].logpdf(sim_pct[obs])))
    pct_cost = np.sum(pct_costs)
    total_cost = pct_cost
    if np.isnan(total_cost):
        total_cost = np.inf*-1
    return total_cost

# Make sampled_params_list to provide to the PyDREAM run call
sampled_params_list = list()

sp_k_NE_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NE_div_0)
sp_k_NE_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NE_div_x)
sp_KD_Kx_NE_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NE_div)

sp_k_NE_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NE_die_0)
sp_k_NE_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NE_die_x)
sp_KD_Kx_NE_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NE_die)

sp_k_NEv1_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NEv1_div_0)
sp_k_NEv1_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NEv1_div_x)
sp_KD_Kx_NEv1_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv1_div)

sp_k_NEv1_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NEv1_die_0)
sp_k_NEv1_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NEv1_die_x)
sp_KD_Kx_NEv1_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv1_die)

sp_k_NEv2_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NEv2_div_0)
sp_k_NEv2_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NEv2_div_x)
sp_KD_Kx_NEv2_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv2_div)

sp_k_NEv2_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NEv2_die_0)
sp_k_NEv2_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NEv2_die_x)
sp_KD_Kx_NEv2_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv2_die)

sp_k_nonNE_div_0 = SampledParam(norm, loc=np.log10(1.1),scale=0.5)
sampled_params_list.append(sp_k_nonNE_div_0)
sp_k_nonNE_div_x = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_nonNE_div_x)
sp_KD_Kx_nonNE_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_nonNE_div)

sp_k_nonNe_die = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_nonNe_die)

sp_kf_diff_ne_nev1 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_ne_nev1)
sp_kr_diff_ne_nev1 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kr_diff_ne_nev1)

sp_kf_diff_ne_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_ne_nev2)
sp_kr_diff_ne_nev2 = SampledParam(norm, loc=np.log10(0.075),scale=0.5)
sampled_params_list.append(sp_kr_diff_ne_nev2)

sp_kf_diff_nev1_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_nev1_nev2)
sp_kr_diff_nev1_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kr_diff_nev1_nev2)

sp_kf_diff_nev2_nonNe = SampledParam(norm, loc=np.log10(5),scale=0.5)
sampled_params_list.append(sp_kf_diff_nev2_nonNe)

converged = False
sampled_params, log_ps = run_dream(parameters=sampled_params_list,
                                   likelihood=likelihood,
                                   niterations=niterations,
                                   nchains=nchains,
                                   multitry=False,
                                   gamma_levels=4,
                                   adapt_gamma=True,
                                   history_thin=1,
                                   model_name='dreamzs_5chain',
                                   verbose=True)
total_iterations = niterations
# Save sampling output (sampled parameter values and their corresponding logps).
for chain in range(len(sampled_params)):
    np.save('dreamzs_5chain_nopop_sampled_params_chain_' + str(chain)+'_'+str(total_iterations), sampled_params[chain])
    np.save('dreamzs_5chain_nopop_logps_chain_' + str(chain)+'_'+str(total_iterations), log_ps[chain])

GR = Gelman_Rubin(sampled_params)
print('At iteration: ',total_iterations,' GR = ',GR)
np.savetxt('dreamzs_5chain_nopop_GelmanRubin_iteration_'+str(total_iterations)+'.txt', GR)
old_samples = sampled_params

if np.any(GR>1.2):
    starts = [old_samples[chain][-1, :] for chain in range(nchains)]
    while not converged:
        total_iterations += niterations
        sampled_params, log_ps = run_dream(parameters=sampled_params_list,
                                           likelihood=likelihood,
                                           niterations=niterations,
                                           nchains=nchains,
                                           start=starts,
                                           multitry=True,
                                           gamma_levels=4,
                                           adapt_gamma=True,
                                           history_thin=1,
                                           model_name='dreamzs_5chain',
                                           verbose=True,
                                           restart=True)
        for chain in range(len(sampled_params)):
            np.save('dreamzs_5chain_nopop_sampled_params_chain_' + str(chain)+'_'+str(total_iterations), sampled_params[chain])
            np.save('dreamzs_5chain_nopop_logps_chain_' + str(chain)+'_'+str(total_iterations), log_ps[chain])
        old_samples = [np.concatenate((old_samples[chain], sampled_params[chain])) for chain in range(nchains)]
        GR = Gelman_Rubin(old_samples)
        print('At iteration: ',total_iterations,' GR = ',GR)
        np.savetxt('dreamzs_5chain_nopop_GelmanRubin_iteration_' + str(total_iterations)+'.txt', GR)
        if np.all(GR<1.2):
            converged = True