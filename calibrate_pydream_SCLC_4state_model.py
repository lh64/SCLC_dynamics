'''
Generated by pydream_it
PyDREAM run script for SCLC_popD_model.py 
'''
from pydream.core import run_dream
from pysb.simulator import ScipyOdeSimulator
import numpy as np
from pydream.parameters import SampledParam
from pydream.convergence import Gelman_Rubin
from scipy.stats import norm,uniform
from SCLC_4state import model
import seaborn as sns
from matplotlib import pyplot as plt
import copy
from itertools import chain
    

# DREAM Settings
# Number of chains - should be at least 3.
nchains = 5
# Number of iterations
niterations = 10000

#Initialize PySB solver object for running simulations.  Simulation timespan should match experimental data.
tspan = np.linspace(0,100, 101)
solver = ScipyOdeSimulator(model)
param_values = np.array([p.value for p in model.parameters])
parameters_idxs = list(np.arange(1,30))
rates_mask = np.concatenate((np.zeros(1,dtype=bool),np.ones(len(param_values[1:]),dtype=bool)))
starting_position = np.log10(param_values[rates_mask])
starts = [np.array(starting_position) for i in range(nchains)]

def normalize(trajectory, trajectories):
    """even though this is not really needed, if the data is already between 1 and 0!"""
    """Rescale a matrix of model trajectories to 0-1"""
    ymin = min([y for x in trajectories for y in x])
    ymax = max([y for x in trajectories for y in x])
    return (trajectory - ymin) / (ymax - ymin)

# USER must add commands to import/load any experimental data for use in the likelihood function!
pct_data = {
'NE_obs': 0.44622156256910767,
'NEv1_obs': 0.017615778739465095,
'NEv2_obs': 0.4483862369313809,
'NonNE_obs': 0.08777642176004649
}

like_pct_data = {}
#for obs in model.observables:
for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
    like_pct_data[obs] = norm(loc=pct_data[obs],scale=(pct_data[obs]/10))

# access with x[()]['NE_obs']

# USER must define a likelihood function!
def likelihood(position):
    Y=np.copy(position)
    param_values[rates_mask] = 10 ** Y
    sim = solver.run(param_values=param_values,tspan=tspan).all
    sim_data_norm = {}
    for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
        sim_data_norm[obs] = normalize(sim[obs], [list(sim[i]) for i in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']])
    # Make the percentage data
    cell_tot = 0
    for i in sim_data_norm:
        cell_tot += sim_data_norm[i][-1]
    sim_pct = {}
    for i in sim_data_norm:
        sim_pct[i] = sim_data_norm[i][-1]/cell_tot
    # Score the percentage data
    pct_costs = []
    for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
        pct_costs.append(np.sum(like_pct_data[obs].logpdf(sim_pct[obs])))
    pct_cost = np.sum(pct_costs)
    total_cost = pct_cost
    if np.isnan(total_cost):
        total_cost = np.inf*-1
    return total_cost

# Make sampled_params_list to provide to the PyDREAM run call
sampled_params_list = list()

sp_k_NE_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NE_div_0)
sp_k_NE_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NE_div_x)
sp_KD_Kx_NE_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NE_div)

sp_k_NE_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NE_die_0)
sp_k_NE_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NE_die_x)
sp_KD_Kx_NE_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NE_die)

sp_k_NEv1_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NEv1_div_0)
sp_k_NEv1_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NEv1_div_x)
sp_KD_Kx_NEv1_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv1_div)

sp_k_NEv1_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NEv1_die_0)
sp_k_NEv1_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NEv1_die_x)
sp_KD_Kx_NEv1_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv1_die)

sp_k_NEv2_div_0 = SampledParam(norm, loc=np.log10(1),scale=0.5)
sampled_params_list.append(sp_k_NEv2_div_0)
sp_k_NEv2_div_x = SampledParam(norm, loc=np.log10(2),scale=0.5)
sampled_params_list.append(sp_k_NEv2_div_x)
sp_KD_Kx_NEv2_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv2_div)

sp_k_NEv2_die_0 = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_NEv2_die_0)
sp_k_NEv2_die_x = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_NEv2_die_x)
sp_KD_Kx_NEv2_die = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_NEv2_die)

sp_k_nonNE_div_0 = SampledParam(norm, loc=np.log10(1.1),scale=0.5)
sampled_params_list.append(sp_k_nonNE_div_0)
sp_k_nonNE_div_x = SampledParam(norm, loc=np.log10(0.9),scale=0.5)
sampled_params_list.append(sp_k_nonNE_div_x)
sp_KD_Kx_nonNE_div = SampledParam(norm, loc=np.log10(1000),scale=0.5)
sampled_params_list.append(sp_KD_Kx_nonNE_div)

sp_k_nonNe_die = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_k_nonNe_die)

sp_kf_diff_ne_nev1 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_ne_nev1)
sp_kr_diff_ne_nev1 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kr_diff_ne_nev1)

sp_kf_diff_ne_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_ne_nev2)
sp_kr_diff_ne_nev2 = SampledParam(norm, loc=np.log10(0.075),scale=0.5)
sampled_params_list.append(sp_kr_diff_ne_nev2)

sp_kf_diff_nev1_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kf_diff_nev1_nev2)
sp_kr_diff_nev1_nev2 = SampledParam(norm, loc=np.log10(0.1),scale=0.5)
sampled_params_list.append(sp_kr_diff_nev1_nev2)

sp_kf_diff_nev2_nonNe = SampledParam(norm, loc=np.log10(5),scale=0.5)
sampled_params_list.append(sp_kf_diff_nev2_nonNe)

converged = False
sampled_params, log_ps = run_dream(parameters=sampled_params_list,
                                   likelihood=likelihood,
                                   niterations=niterations,
                                   nchains=nchains,
                                   multitry=False,
                                   gamma_levels=4,
                                   adapt_gamma=True,
                                   history_thin=1,
                                   model_name='dreamzs_5chain',
                                   verbose=True)
total_iterations = niterations
# Save sampling output (sampled parameter values and their corresponding logps).
for chain in range(len(sampled_params)):
    np.save('dreamzs_5chain_nopop_sampled_params_chain_' + str(chain)+'_'+str(total_iterations), sampled_params[chain])
    np.save('dreamzs_5chain_nopop_logps_chain_' + str(chain)+'_'+str(total_iterations), log_ps[chain])

GR = Gelman_Rubin(sampled_params)
print('At iteration: ',total_iterations,' GR = ',GR)
np.savetxt('dreamzs_5chain_nopop_GelmanRubin_iteration_'+str(total_iterations)+'.txt', GR)
old_samples = sampled_params

if np.any(GR>1.2):
    starts = [old_samples[chain][-1, :] for chain in range(nchains)]
    while not converged:
        total_iterations += niterations
        sampled_params, log_ps = run_dream(parameters=sampled_params_list,
                                           likelihood=likelihood,
                                           niterations=niterations,
                                           nchains=nchains,
                                           start=starts,
                                           multitry=True,
                                           gamma_levels=4,
                                           adapt_gamma=True,
                                           history_thin=1,
                                           model_name='dreamzs_5chain',
                                           verbose=True,
                                           restart=True)
        for chain in range(len(sampled_params)):
            np.save('dreamzs_5chain_nopop_sampled_params_chain_' + str(chain)+'_'+str(total_iterations), sampled_params[chain])
            np.save('dreamzs_5chain_nopop_logps_chain_' + str(chain)+'_'+str(total_iterations), log_ps[chain])
        old_samples = [np.concatenate((old_samples[chain], sampled_params[chain])) for chain in range(nchains)]
        GR = Gelman_Rubin(old_samples)
        print('At iteration: ',total_iterations,' GR = ',GR)
        np.savetxt('dreamzs_5chain_nopop_GelmanRubin_iteration_' + str(total_iterations)+'.txt', GR)
        if np.all(GR<1.2):
            converged = True

###### Everything beyond this point is for plotting and visualization of results ######

## If you are not doing this immediately after the PyDREAM run,
## 1) You'll have to import everything from the PyDREAM run file
## 2) You can load sampled_params and logps with commands such as these:
# sampled_params[4] = np.load('dreamzs_5chain_nopop_sampled_params_chain_4_10000.npy')[()]
# logps[4] = np.load('dreamzs_5chain_nopop_logps_chain_4_10000.npy')[()]
# etc
## You'll also have to account for the solver and everything you need to get simulation trajectories
# tspan = np.linspace(0,100, 101)
# solver = ScipyOdeSimulator(model)
# param_values = np.array([p.value for p in model.parameters])
# parameters_idxs = list(np.arange(1,30))
# rates_mask = np.concatenate((np.zeros(1,dtype=bool),np.ones(len(param_values[1:]),dtype=bool)))
##

## Plot log-p-values
iters = [i for i in range(10000)] #number of iterations
fig = plt.figure(figsize=(18,10))
columns = 3
rows = 2
for chain in range(0,5):
    fig.add_subplot(rows,columns,chain+1)
    plt.plot(iters,logps[chain][:,0], color='b')
    #plt.ylim(-30,0)
    plt.xlabel("Iteration", fontsize=14)
    plt.ylabel("Likelihood", fontsize=14, labelpad=15)
    plt.title('Logps over iterations for chain '+str(chain))

plt.tight_layout()
#plt.show()
fig.savefig('SCLC_logpvalues.png')
plt.close(fig)


## Get simulation trajectory values in order to turn them into proportions
all_vals = {}
ind = 0
tot_vals = []

for j in range(0,5):
    print (j)
    for i in sampled_params[j][9800:]:
        Y=np.copy(i)
        param_values[rates_mask] = 10 ** Y
        sim = solver.run(param_values=param_values,tspan=tspan).all
        sim_data_norm = {}
        tot_vals.append(np.zeros(101))
        for obs in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']:
            toAdd = normalize(sim[obs], [list(sim[i]) for i in ['NE_obs','NEv1_obs','NEv2_obs','NonNE_obs']])
            tot_vals[ind] = np.sum([tot_vals[ind],toAdd],axis=0)
            if not obs in all_vals:
                all_vals[obs] = [toAdd]
            else:
                all_vals[obs].append(toAdd)
        ind += 1

## Plot the proportions individually
fig = plt.figure(figsize=(18,10))
columns = 2
rows = 2

NE_vals = all_vals['NE_obs']
fig.add_subplot(rows,columns,1)
plt.title('NE proportion over time,\n1000 sets of parameters with best p-vals')
plt.ylim(0,1)
for i in np.true_divide(NE_vals,tot_vals):
    plt.plot(i,color='b',alpha=0.05)

NEv1_vals = all_vals['NEv1_obs']
fig.add_subplot(rows,columns,2)
plt.title('NEv1 proportion over time,\n1000 sets of parameters with best p-vals')
plt.ylim(0,1)
for i in np.true_divide(NEv1_vals,tot_vals):
    plt.plot(i,color='orange',alpha=0.05)

NEv2_vals = all_vals['NEv2_obs']
fig.add_subplot(rows,columns,3)
plt.title('NEv2 proportion over time,\n1000 sets of parameters with best p-vals')
plt.ylim(0,1)
for i in np.true_divide(NEv2_vals,tot_vals):
    plt.plot(i,color='g',alpha=0.05)

NonNE_vals = all_vals['NonNE_obs']
fig.add_subplot(rows,columns,4)
plt.title('NonNE proportion over time,\n1000 sets of parameters with best p-vals')
plt.ylim(0,1)
for i in np.true_divide(NonNE_vals,tot_vals):
    plt.plot(i,color='r',alpha=0.05)

plt.tight_layout()
#plt.show()
fig.savefig('SCLC_proportions_over_time_per_subtype.png')
plt.close(fig)

## Plot the proportions over time as well as the average proportion over time
avg_vals = {}
plot_vals = {}

avg_vals['NE'] = np.mean(np.true_divide(NE_vals,tot_vals),axis=0)

sum_prev = np.zeros(101)
sum_prev = np.sum([sum_prev,np.mean(np.true_divide(NE_vals,tot_vals),axis=0)],axis=0)

avg_vals['NEv1'] = np.sum([sum_prev,np.mean(np.true_divide(NEv1_vals,tot_vals),axis=0)],axis=0)
sum_prev = np.sum([sum_prev,np.mean(np.true_divide(NEv1_vals,tot_vals),axis=0)],axis=0)

avg_vals['NEv2'] = np.sum([sum_prev,np.mean(np.true_divide(NEv2_vals,tot_vals),axis=0)],axis=0)
sum_prev = np.sum([sum_prev,np.mean(np.true_divide(NEv2_vals,tot_vals),axis=0)],axis=0)

avg_vals['NonNE'] = np.sum([sum_prev,np.mean(np.true_divide(NonNE_vals,tot_vals),axis=0)],axis=0)

plot_vals['NE'] = []
plot_vals['NEv1'] = []
plot_vals['NEv2'] = []
plot_vals['NonNE'] = []

plot_vals['NE'] = np.true_divide(NE_vals,tot_vals)
plot_sum_prev = copy.deepcopy(np.true_divide(NE_vals,tot_vals))

plot_vals['NEv1'] = np.sum([plot_sum_prev,np.true_divide(NEv1_vals,tot_vals)],axis=0)
plot_sum_prev = np.sum([plot_sum_prev,np.true_divide(NEv1_vals,tot_vals)],axis=0)

plot_vals['NEv2'] = np.sum([plot_sum_prev,np.true_divide(NEv2_vals,tot_vals)],axis=0)
plot_sum_prev = np.sum([plot_sum_prev,np.true_divide(NEv2_vals,tot_vals)],axis=0)

plot_vals['NonNE'] = np.sum([plot_sum_prev,np.true_divide(NonNE_vals,tot_vals)],axis=0)

for i in plot_vals['NE']:
	plt.plot(i,color='darkblue',alpha=0.05)

for i in plot_vals['NEv1']:
	plt.plot(i,color='darkorange',alpha=0.05)

for i in plot_vals['NEv2']:
	plt.plot(i,color='darkgreen',alpha=0.05)

for i in plot_vals['NonNE']:
	plt.plot(i,color='darkred',alpha=0.05)

plt.plot(avg_vals['NE'],linewidth=5,color='navy',linestyle='--')
plt.fill_between(tspan, avg_vals['NE'], label='NE')
plt.plot(avg_vals['NEv1'],linewidth=5,color='orangered',linestyle='--')
plt.fill_between(tspan, avg_vals['NE'], avg_vals['NEv1'], label='NEv1')
plt.plot(avg_vals['NEv2'],linewidth=5,color='olive',linestyle='--')
plt.fill_between(tspan, avg_vals['NEv1'], avg_vals['NEv2'], label='NEv2')
plt.plot(avg_vals['NonNE'],linewidth=5,color='darkred',linestyle='--')
plt.fill_between(tspan, avg_vals['NEv2'], avg_vals['NonNE'], label='NonNE')

plt.xlim(0,20)
plt.ylim(0,1)
plt.xlabel('time (days)')
plt.ylabel('proportion of the population')
plt.title('Proportion of the SCLC population over time')
plt.legend()
plt.tight_layout()
#plt.show()
plt.savefig('SCLC_average_proportions_over_time.png')
plt.close(fig)


## Need to specify these if you didn't run this immediately after PyDREAM
# old_samples = copy.deepcopy(sampled_params)
# nchains = 5
# total_iterations = 10000


## Plot the parameter distributions
matplotlib.rcParams.update({'font.size': 6})
total_iterations = len(old_samples[0])
burnin = int(total_iterations/2)
samples = np.concatenate(tuple([old_samples[i][burnin:, :] for i in range(nchains)]))
ndims = len(param_values)-1
colors = sns.color_palette(n_colors=ndims)

parameters_idxs = list(np.arange(1,30))
paramcolorlist = [
'gray',
'deepskyblue',
'lightcoral',
'lawngreen',
'plum',
'peachpuff',
'darkseagreen',
'goldenrod',
'mediumpurple',
'gold',
'springgreen',
'khaki',
'slateblue',
'yellowgreen',
'mediumturquoise',
'darkslategray',
'sandybrown',
'olivedrab',
'darkcyan',
'gainsboro',
'steelblue',
'darksalmon',
'mediumorchid',
'sienna',
'hotpink',
'crimson',
'orangered',
'navajowhite',
'navy'
]

fig = plt.figure(figsize=(18,10))
columns = 5
rows = 6
for dim in range(ndims):
    fig.add_subplot(rows, columns, dim+1)
    param_toprint = (model.parameters[int(parameters_idxs[dim])].name)        
    #plt.xlim(-3,3)
    #plt.ylim(0,0.8)
    sns.distplot(samples[:, dim], color=paramcolorlist[dim], norm_hist=True,label=param_toprint)
    plt.title(param_toprint)    

plt.tight_layout()
#plt.show()
fig.savefig('SCLC_paramvalues.png')
plt.close(fig)

